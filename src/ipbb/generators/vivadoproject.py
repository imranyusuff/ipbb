
import time
import os
import collections
import copy

from string import Template as tmpl
from ..defaults import kTopEntity
from os.path import abspath, join, split, splitext


def createPresynthScript(aLibraries, aSourceAreaPath, aScriptPath):
    lScriptContents = [
        '# Autogenerated presynth script (for setting generics containing build metadata)',
        '',
        '# Build time (seconds since epoch)',
        'set UNIX_TIME [format %04X [clock seconds]]',
        'puts UNIX_TIME=$UNIX_TIME',
        'set GENERIC_VALUES "UNIX_TIME=32\'h$UNIX_TIME"',
        ]

    # For each source area, 3 generics:
    #  * <NAME>_GIT_SHA: 28 bits
    #  * <NAME>_GIT_CLEAN: 1 bit
    #  * <NAME>_GIT_REF: string (branch/tag name)
    # 3 generics covering all source areas (values for each repo concantenated):
    #  * GIT_REPOS_NAME: std_logic_vector, 160 bits per repo (UTF-8)
    #  * GIT_REPOS_REF: std_logic_vector, 160 bits per repo (UTF-8)
    #  * GIT_REPOS_SHA: std_logic_vector, 28 bits per repo
    #  * GIT_REPOS_CLEAN: std_logic_vector, 1 bit per repo
    #
    # Commands used to extract git info:
    #  1) git rev-parse --abbrev-ref HEAD   => branch name for branches; 'HEAD' for tagged or specific commits
    #  2) git describe --exact-match        => tag name if current commit matches a tag
    #  3) git rev-parse --short HEAD        => 7-char SHA
    #  4) git diff --quiet HEAD             => Non-zero exit code if local changes not included in commit
    lScriptContents += [
        '',
        'set ORIG_PWD [pwd]',
        'set GIT_REPOS_NAME {}\'h'.format(160 * len(aLibraries)),
        'set GIT_REPOS_REF {}\'h'.format(160 * len(aLibraries)),
        'set GIT_REPOS_SHA {}\'h'.format(28 * len(aLibraries)),
        'set GIT_REPOS_CLEAN {}\'b'.format(len(aLibraries)),
        '',
        'foreach libName {{{}}} {{'.format(' '.join(aLibraries)),
        '  puts "SOURCE AREA: $libName"',
        '  set varPrefix [string toupper $libName]',
        '  puts varPrefix=$varPrefix',
        '  set varPrefix [string map {- _} $varPrefix]',
        '  puts varPrefix=$varPrefix',
        '  binary scan [encoding convertto utf-8 "$libName"] H* hex',
        '  puts "UTF-8-encoded name: $hex"',
        '  append GIT_REPOS_NAME [format %-040s [string range $hex 0 39]]',
        '',
        '  cd {}/$libName'.format(aSourceAreaPath),
        '  puts "pwd=[pwd]"',
        #
        '  set GIT_REF [exec git rev-parse --abbrev-ref HEAD]',
        '  if {$GIT_REF == {HEAD}} {',
        '    set GIT_REF [exec git describe --exact-match]',
        '  }',
        '  puts GIT_REF=$GIT_REF',
        '  binary scan [encoding convertto utf-8 "$GIT_REF"] H* hex',
        '  puts "UTF-8-encoded ref: $hex"',
        '  append GIT_REPOS_REF [format %-040s [string range $hex 0 39]]',
        #
        '  set GIT_SHA [exec git rev-parse --short HEAD]',
        '  puts GIT_SHA=$GIT_SHA',
        '  set [set varPrefix]_GIT_SHA "28\'h$GIT_SHA"',
        '  append GIT_REPOS_SHA $GIT_SHA',
        #
        '  set GIT_CLEAN [string match 0 [catch { exec git diff --quiet HEAD }]]',
        '  puts GIT_CLEAN=$GIT_CLEAN',
        '  append GIT_REPOS_CLEAN $GIT_CLEAN',
        '  set [set varPrefix]_GIT_CLEAN $GIT_CLEAN',
        #
        '  append GENERIC_VALUES " [set varPrefix]_GIT_SHA=28\'h$GIT_SHA [set varPrefix]_GIT_CLEAN=1\'b$GIT_CLEAN [set varPrefix]_GIT_REF={\\"$GIT_REF\\"}"',
        '}',
        'append GENERIC_VALUES " GIT_REPOS_NAME=$GIT_REPOS_NAME GIT_REPOS_REF=$GIT_REPOS_REF GIT_REPOS_SHA=$GIT_REPOS_SHA GIT_REPOS_CLEAN=$GIT_REPOS_CLEAN"',
        'puts ORIG_PWD=$ORIG_PWD',
        'cd $ORIG_PWD'
        ]

    lScriptContents += [
        '',
        'puts "Generics: $GENERIC_VALUES"',
        'puts "Current fileset: [current_fileset]"',
        'puts "Current fileset - files: [get_files [current_fileset]]"',
        'set_property generic "$GENERIC_VALUES" [current_fileset]'
        ]

    with open(aScriptPath, 'w') as f:
        f.write('\n'.join(lScriptContents))



# --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
class VivadoProjectGenerator(object):
    """
    Attributes:
        filesets (obj:`dict`): extension-to-fileset association
    """

    filetypes = {
        'ip' : ('.xci', '.xcix'),
        'constr' : ('.xdc', '.tcl'),
        'design' : ('.vhd', '.vhdl', '.v', '.sv', '.xci', '.xcix', '.ngc', '.edn', '.edf', '.mem', '.mif'),
    }

    @staticmethod
    def fileset(aSrcCmd):
        lName, lExt = splitext(aSrcCmd.filepath)

        lFileSet = None
        if lExt in ('.xci', '.xcix'):
            lFileSet = 'sources_1'

        elif lExt in ('.xdc', '.tcl'):
            lFileSet = 'constrs_1'

        elif lExt in ('.vhd', '.vhdl', '.v', '.sv', '.ngc', '.edn', '.edf', '.mem', '.mif'):
            if aSrcCmd.useInSynth:
                lFileSet = 'sources_1'
            elif aSrcCmd.useInSim:
                lFileSet = 'sim_1'

        return lFileSet

    reqsettings = {'device_name', 'device_package', 'device_speed'}

    # --------------------------------------------------------------
    def __init__(self, aProjInfo, aIPCachePath=None, aTurbo=True):
        self.projInfo = aProjInfo
        self.ipCachePath = aIPCachePath
        self.turbo = aTurbo

    # --------------------------------------------------------------
    def write(self, aOutput, aSettings, aComponentPaths, aCommandList, aLibs):

        if not self.reqsettings.issubset(aSettings):
            raise RuntimeError(f"Missing required variables: {', '.join(self.reqsettings.difference(aSettings))}")
        lXilinxPart = f'{aSettings["device_name"]}{aSettings["device_package"]}{aSettings["device_speed"]}'

        # ----------------------------------------------------------
        write = aOutput

        lWorkingDir = abspath(join(self.projInfo.path, self.projInfo.name))
        lTopEntity = aSettings.get('top_entity', kTopEntity)

        lSimTopEntity = aSettings.get('vivado.sim_top_entity', None)
        # ----------------------------------------------------------

        write('# Autogenerated project build script')
        write(time.strftime("# %c"))
        write()

        write(
            f'create_project {self.projInfo.name} {lWorkingDir} -part {lXilinxPart} -force'
        )

        # if 'board_part' in aSettings:
        #     write('set_property -name "board_part" -value "{board_part}" -objects [current_project]'.format(**aSettings))
        # if 'dsa_board_id' in aSettings:
        #     write('set_property -name "dsa.board_id" -value "{dsa_board_id}" -objects [current_project]'.format(**aSettings))


        # Add ip repositories to the project variable
        write('set_property ip_repo_paths {{{}}} [current_project]'.format(
            ' '.join(map( lambda c: c.filepath, aCommandList['iprepo']))
        ))

        for util in (c for c in aCommandList['util']):
            write(f'add_files -norecurse -fileset utils_1 {util.filepath}')

        write('if {[string equal [get_filesets -quiet constrs_1] ""]} {create_fileset -constrset constrs_1}')
        write('if {[string equal [get_filesets -quiet sources_1] ""]} {create_fileset -srcset sources_1}')

        for setup in (c for c in aCommandList['setup'] if not c.finalize):
            write(f'source {setup.filepath}')

        lXciBasenames = []

        lSrcs = aCommandList['src']

        # Grouping commands here, where the order matters only for constraint files
        lSrcCommandGroups = collections.OrderedDict()

        for src in lSrcs:
            #
            # TODO: rationalise the file-type base file handling
            #     Now it's split betweem the following is statement and
            #     the fileset method
            #

            # Extract path tokens
            _, lBasename = split(src.filepath)
            lName, lExt = splitext(lBasename)

            # local list of commands
            lCommands = []

            if lExt in ('.xci', '.xcix'):

                c = f'import_files -norecurse -fileset {self.fileset(src)} $files'
                f = src.filepath

                lCommands += [(c, f)]

                lXciBasenames.append(lName)
                # lXciTargetFiles.append(lTargetFile)
            else:

                c = f'add_files -norecurse -fileset {self.fileset(src)} $files'
                f = src.filepath
                lCommands += [(c, f)]

                if src.vhdl2008:
                    c = 'set_property FILE_TYPE {VHDL 2008} [get_files {$files}]'
                    f = src.filepath
                    lCommands += [(c, f)]

                if lExt == '.tcl':
                    c = 'set_property USED_IN implementation [get_files {$files}]'
                    f = src.filepath
                    lCommands += [(c, f)]

                if src.lib:
                    c = f'set_property library {src.lib} [ get_files {{$files}} ]'
                    f = src.filepath
                    lCommands += [(c, f)]

            for c, f in lCommands:
                if self.turbo:
                    lSrcCommandGroups.setdefault(c, []).append(f)
                else:
                    write(tmpl(c).substitute(files=f))

        if self.turbo:
            for c, f in lSrcCommandGroups.items():
                write(tmpl(c).substitute(files=' '.join(f)))


        ########################################################################
        ########################################################################

        lPresynthScriptPath = join(lWorkingDir, 'set_generics_presynth.tcl')
        createPresynthScript([k for k in aComponentPaths], join(self.projInfo.path, '..', '..', 'src'), lPresynthScriptPath)

        # write('add_files -norecurse -fileset constrs_1 {}'.format(lPresynthScriptPath))
        # write('set_property USED_IN synthesis [get_files {{{}}}]'.format(lPresynthScriptPath))

        write('add_files -norecurse -fileset utils_1 {}'.format(lPresynthScriptPath))
        write('set_property STEPS.SYNTH_DESIGN.TCL.PRE "{}" [get_runs synth_1]'.format(lPresynthScriptPath))
        ########################################################################
        ########################################################################


        write(f'set_property top {lTopEntity} [get_filesets sources_1]')
        if lSimTopEntity:
            write(f'set_property top {lSimTopEntity} [get_filesets sim_1]')

        if self.ipCachePath:
            write(f'config_ip_cache -import_from_project -use_cache_location {abspath(self.ipCachePath)}')

        for i in lXciBasenames:
            write(f'upgrade_ip [get_ips {i}]')
        # for i in lXciTargetFiles:
            # write('create_ip_run [get_files {0}]'.format(i))
        for i in lXciBasenames:
            write(f'delete_ip_run [get_ips {i}]')
            write(f'generate_target all [get_ips {i}]')
            write(f'create_ip_run [get_ips {i}]')

        for setup in (c for c in aCommandList['setup'] if c.finalize):
            write(f'source {setup.filepath}')

        write('close_project')
    # --------------------------------------------------------------

# --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
